---
title: Distributed Tracing
owner: Diego
---

Cloud Foundry provides support for distributed tracing, enabling transactions
to be monitored and analyzed across multiple Cloud Foundry components. For each
transaction initiated in the GoRouter, a new trace context is generated and
then propagated to all participating systems.

Each participating system adds this unique identifier to logs, allowing
operators to trace logs and debug errors specific to that transaction. This
feature is particularly beneficial when used in conjunction with log
aggregation tools such as Splunk.

## <a id='unique-trace-id'></a> Unique trace identification

For every request in Cloud Foundry, GoRouter generates a unique
`X-Vcap-Request-Id` header. `X-Vcap-Request-Id` is a v4 UUID according to [RFC
4122](http://www.ietf.org/rfc/rfc4122.txt).

If Zipkin is enabled (see [Enabling Zipkin tracing in Cloud
Foundry](/adminguide/zipkin_tracing.html)), GoRouter also generates B3 headers
for each request unless they were provided by the client:

* `X-B3-Traceid` - 128-bit in length and indicates the overall ID of the trace.
Every span in a trace shares this ID. The `X-B3-TraceId` header is encoded as
32 lower-hex characters.
* `X-B3-Spanid` - 64-bit in length and indicates the position of the current
operation in the trace tree. The `X-B3-SpanId` header is encoded as 16
lower-hex characters.
* `B3` - a combination of `X-B3-Traceid` and `X-B3-Spanid` headers in the
format: `{TraceId}-{SpanId}`

If W3C is enabled via `router.tracing.enable_w3c` deployment manifest property,
GoRouter also generates W3C headers for each request unless they were provided
by the client. W3C headers are generated according to the [W3C headers
format](https://www.w3.org/TR/trace-context/):

* `traceparent` - consists of 4 fields in the format:
`{version-format}-{trace-id}-{parent-id}-{trace-flags}`
* `tracestate` - is generated from `router.tracing.w3c_tenant_id` deployment
property and `parent-id` used in the transparent header:
`{w3c_tenant_id}={parent-id}`

If B3 headers are provided and they are in a proper v4 UUID format, GoRouter
will use them for `X-Vcap-Request-Id` and W3C headers. If they are not
provided, GoRouter will generate v4 UUID and use it for B3 headers,
`X-Vcap-Request-Id` and W3C headers.

## <a id='distributed-tracing-example'></a> Using trace identification to analyze a specific Cloud Foundry request

In this example we will make a request to Cloud Foundry to scale an
application. This request is handled by several Cloud Foundry components:

1. The request is initially received by GoRouter. GoRouter generates unique
trace headers for this request. It then forwards this request with the trace
headers to the Cloud Controller.
1. Cloud Controller updates the LRP (Long Running Process) for the application,
reflecting the new number of instances. It subsequently sends the LRP request
with the appended trace headers to BBS.
1. BBS generates a new request with the trace headers to Auctioneer to schedule
a new application instance.
1. Auctioneer selects a Diego cell that has enough resources to run the
application instance. It then sends a request with the trace headers to Rep on
that Diego Cell, instructing it to run this new application instance.
1. Finally, Rep generates a request to Garden. This request with the same trace
information instructs Garden to create a container where application processes
will run.

<%= image_tag('distributed-tracing-flow.jpg') %>

Each component in this transaction:

* Retains the original request's `trace-id` and forwards it in all downstream
requests.
* Generates a unique span-id for each request, which remains exclusive to
that particular component.
* Both the `trace-id` and `span-id` are recorded in logs related to that
request handling.

This transaction is characterized by a single trace-id that identifies it
across all hops, while each individual hop is marked by its own unique span-id.

We will use the `CF_TRACE` environment variable to get the generated B3 trace headers.

```bash
CF_TRACE=true cf scale myapp -i 2
```

The output will contain a sequence of requests and responses from Cloud
Foundry. Initially, the CLI retrieves the application GUID, followed by an API
request to scale the application. The response to this request will include B3
headers, which are generated by the GoRouter.

```bash
Scaling app myapp in org myorg / space myspace as admin...

REQUEST:
POST /v3/apps/8e0f1501-ba1f-4efe-af90-b61f2e5a1384/processes/web/actions/scale 
...
{
  "instances": 2
}


RESPONSE:
HTTP/1.1 202 Accepted
...
X-B3-Spanid: 67bde5d7dcd81f84
X-B3-Traceid: 0c2cc9583f004a4167bde5d7dcd81f84
...
```
It is also possible to tell the GoRouter to use user-provided B3 headers:


```bash
cf curl -H "X-B3-Traceid: 8c436ec437e545227fe76a3eba99ca21" -H "X-B3-Spanid: 7fe76a3eba99ca21" -d '{"instances" : 3}' /v3/apps/8e0f1501-ba1f-4efe-af90-b61f2e5a1384/processes/web/actions/scale
```

<p class='note'><strong>Note:</strong> Note that both X-B3-Traceid and X-B3-Spanid must be set</p>

The `X-B3-Traceid` can then be used to filter logs in aggregation tools to see
how this request was handled by the GoRouter, Cloud Controller, BBS, Rep,
Auctioneer and finally how a container for a new application instance was
created in Garden.

<%= image_tag('distributed-tracing-logs.png') %>
